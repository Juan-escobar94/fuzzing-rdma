@misc{fetzer20,
Author = {Fetzer, Christof and Martin, Andre},
title = {Lecture Notes in Software Fault Tolerance},
year = {2020},
publisher = {TU Dresden}
}


@book{korbethLinuxDeviceDrivers2005,
  title = {Linux {{Device Drivers}}},
  author = {Korbeth, Jonath and Rubini, Alessandro and {Kroah-Hartman}, Greg},
  year = {2005},
  edition = {Third},
  publisher = {{O'Reilly Media, Inc.}},
  isbn = {0-596-00590-3}
}


@book{kroah-hartman06,
author = {Kroah-Hartman, Greg},
title = {Linux Kernel in a Nutshell (In a Nutshell (O'Reilly))},
year = {2006},
isbn = {0596100795},
publisher = {O'Reilly Media, Inc.},
abstract = {Written by a leading developer and maintainer of the Linux kernel, Linux Kernel in a Nutshell is a comprehensive overview of kernel configuration and building, a critical task for Linux users and administrators.No distribution can provide a Linux kernel that meets all users' needs. Computers big and small have special requirements that require reconfiguring and rebuilding the kernel. Whether you are trying to get sound, wireless support, and power management working on a laptop or incorporating enterprise features such as logical volume management on a large server, you can benefit from the insights in this book.Linux Kernel in a Nutshell covers the entire range of kernel tasks, starting with downloading the source and making sure that the kernel is in sync with the versions of the tools you need. In addition to configuration and installation steps, the book offers reference material and discussions of related topics such as control of kernel options at runtime.A key benefit of the book is a chapter on determining exactly what drivers are needed for your hardware. Also included are recipes that list what you need to do to accomplish a wide range of popular tasks.}
}

@manual{rdmamanual,
title = {RDMA Aware Networks Programming User Manual},
organization = {Mellanox Technologies},
address = {Sunnyvale, CA 94085},
edition = {1.7},
year = 2015
}

@online{mellanox-community,
title = {How to configure SoftRoCE},
url = {https://community.mellanox.com/s/article/howto-configure-soft-roce},
lastaccessed = {February 1, 2021}
}

@online{afl,
title = {American Fuzzy Lop (AFL)},
url ={https://github.com/google/AFL},
lastaccessed = {march 6, 2021}
}

@online{libfuzzer,
title = {Libfuzzer},
url ={https://llvm.org/docs/LibFuzzer.html},
lastaccessed = {march 6, 2021}
}

@online{syzkaller,
title = {Syzkaller},
url = {https://github.com/google/syzkaller},
lastaccessed = {march 6, 2021}
}

@article{kafl,
author = {Sergej Schumilo, et-al.},
title = {kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels},
journal = {usenix},
year = 2017,
month = jul
}

@book{intro-ib,
author = {Paul Grun},
title = {Introduction to InfiniBand™ for End Users},
publisher = {Infiniband™ Trade Association},
year = 2010
}

@book{shanley-02,
author = {Shanley, Tom},
title = {Infiniband Network Architecture},
year = {2002},
isbn = {9780321117656},
publisher = {Addison-Wesley Professional},
}

@article{bedeir10,
author = {Tarick Bedeir},
title = {Building an RDMA-Capable Application with IB Verbs},
journal = {schlumberger},
year = 2010,
month = aug
}


@article{mcnallyFuzzingStateArt2012,
  title = {Fuzzing: {{The State}} of the {{Art}}},
  author = {McNally, Richard and Yiu, Ken and Grove, Duncan and Gerhardy, Damien},
  year = {2012},
  month = feb,
  journal = {DSTO Defence Science and Technology Organisation}
}


@article{martin97,
author ={Richard P. Martin, Amin M. Vahdat, David E. Culler and Thomas E. Anderson},
title = {Effects of Communication Latency, Overhead, and Bandwidth in a Cluster Architecture},
journal = {ACM SIGARCH Computer Architecture News},
year = 1997
}

@article{shalfHPCInterconnectsEnd2019,
  title = {{{HPC Interconnects}} at the {{End}} of {{Moore}}'s {{Law}}},
  author = {Shalf, John},
  year = {2019},
  month = mar,
  journal = {2019 Optical Fiber Communications Conference and Exhibition (OFC)}
}

@manual{infinibandvol107,
title = {InfiniBand Architecture Specification Volume 1},
organization = {Infiniband Trade Association},
edition = {1.2.1},
year = 2007
}

@manual{rocev2,
title={Supplement to InfiniBand Architecture Specification Volume 1, Annex A17: RoCEv2},
organization = {Infiniband Trade Association},
edition = {1.2.1},
year = 2014
}

@manual{softroce,
title={Soft-RoCE: RDMA Transport in a software implementation},
organization = {Infiniband Trade Association},
year = 2015
}

}

@article{chenLinuxKernelVulnerabilities2011,
  title = {Linux Kernel Vulnerabilities: {{State}}-of-the-Art Defenses and Open Problems},
  author = {Chen, Haogang and Mao, Yandong and Wang, Xi and Zhou, Dong and Zeldovich, Nickolai and Kaashoek, M. Frans},
  year = {2011},
  month = nov,
  file = {/home/juan/Zotero/storage/8AY4USDX/_.pdf},
  journal = {APSys '11: Proceedings of the Second Asia-Pacific Workshop on Systems}
}

@article{corinaDIFUZEInterfaceAware2017,
  title = {{{DIFUZE}}: {{Interface Aware Fuzzing}} for {{Kernel Drivers}}},
  author = {Corina, Jake and Aravind, Machiry and Salls, Christopher and Shoshitaishvili, Yan and Hao, Shuang and Kruegel, Christopher and Vigna, Giovanni},
  year = {2017},
  month = oct,
  file = {/home/juan/Zotero/storage/26VDGF7G/_.pdf},
  journal = {CCS '17: 2017 ACM SIGSAC Conference on Computer and Communications Security}
}

@article{chouEmpiricalStudyOperating2001,
  title = {An {{Empirical Study}} of {{Operating Systems Errors}}},
  author = {Chou, Andy and Yang, Junfeng and Chelf, Benjamin and Hallem, Seth and Engler, Dawson},
  year = {2001},
  file = {/home/juan/SciencePapers/empstudyoserrors2001.pdf},
  journal = {SOSP '01: Proceedings of the eighteenth ACM symposium on Operating systems principles}
}


@misc{vanderstoepAndroidProtectingKernel2016,
  title = {Android: Protecting the Kernel},
  author = {Vander Stoep, Jeff},
  year = {2016},
  month = jul,
  publisher = {{The Linux Foundation}}
}


@misc{vyukovSyzkallerAdventuresContinuous2020,
  title = {Syzkaller: {{Adventures}} in {{Continuous Coverage}}-Guided {{Kernel Fuzzing}}},
  author = {Vyukov, Dmitry},
  year = {2020},
  month = feb,
  address = {{Tel Aviv}}
}

@misc{osherovichImprovingTestingRDMA2018,
  title = {Improving Testing of {{RDMA}} with Syzkaller, {{RXE}} and {{Python}}},
  author = {Osherovich, Noa and Gunthorpe, Jason},
  year = {2018},
  month = nov,
  address = {{Vancouver}}
}


@article{liFastSyzkallerImprovingFuzz2019,
  title = {{{FastSyzkaller}}: {{Improving Fuzz Efficiency}} for {{Linux Kernel Fuzzing}}},
  author = {Li, Dan and Chen, Hua},
  year = {2019},
  file = {/home/juan/Zotero/storage/34G3N3HM/_.pdf},
  journal = {IOP Conf. Series: Journal of Physics: Conf. Series 1176}
}


@article{okechInvestigatingExecutionPath2013,
  title = {Investigating {{Execution Path Non}}-Determinism in the {{Linux Kernel}}},
  author = {Okech, Peter and Mc Guire, Nicholas and Fetzer, Christof and {Okelo-Odongo}, William},
  year = {2013},
  journal = {Proc. 14th RealTime Linux Workshop, Lugano}
}

@misc{KcovCodeCoveragea,
  title = {Kcov: Code Coverage for Fuzzing \textemdash{} {{The Linux Kernel}} Documentation},
  file = {/home/juan/Zotero/storage/AFKZ9GCA/kcov.html},
  howpublished = {https://www.kernel.org/doc/html/latest/dev-tools/kcov.html}
}


@misc{KernelAddressSanitizer,
  title = {The {{Kernel Address Sanitizer}} ({{KASAN}}) \textemdash{} {{The Linux Kernel}} Documentation},
  file = {/home/juan/Zotero/storage/C3HBP3BX/kasan.html},
  howpublished = {https://www.kernel.org/doc/html/latest/dev-tools/kasan.html}
}


@misc{Syzbot,
  title = {Syzbot},
  file = {/home/juan/Zotero/storage/BMEJ3T39/upstream.html},
  howpublished = {https://syzkaller.appspot.com/upstream}
}


@misc{QPStateMachine2012,
  title = {{{QP}} State Machine},
  year = {2012},
  month = may,
  abstract = {Contents1 QP State transitions2 Reset state2.1 Description2.2 Work Requests2.3 Packets3 Init state3.1 Description3.2 Work Requests3.3 Packets4 RTR state4.1 Description4.2 Work Requests4.3 Packets5 RTS state5.1 Description5.2 Work Requests5.3 Packets6 SQD state6.1 Work Requests6.2 Packet7 SQE state7.1 Description7.2 Work Requests7.3 Packets8 Error state8.1 Description8.2 Work Requests8.3 Packet9 Summary Since a QP is one of the important objects...},
  file = {/home/juan/Zotero/storage/KLL3QY3Q/qp-state-machine.html},
  howpublished = {https://www.rdmamojo.com/2012/05/05/qp-state-machine/},
  journal = {RDMAmojo}
}


@misc{hillandRDMAProtocolVerbs,
  title = {{{RDMA Protocol Verbs Specification}}},
  author = {Hilland {$<$}jeff.hilland@hp.com{$>$}, Jeff},
  file = {/home/juan/Zotero/storage/J8W9VVWK/draft-hilland-rddp-verbs-00.html},
  howpublished = {https://tools.ietf.org/html/draft-hilland-rddp-verbs-00},
  language = {en}
}


@misc{GoogleSyzkaller2021,
  title = {Google/Syzkaller},
  year = {2015},
  month = apr,
  abstract = {syzkaller is an unsupervised coverage-guided kernel fuzzer},
  copyright = {Apache-2.0 License         ,                 Apache-2.0 License},
  howpublished = {https://github.com/google/syzkaller},
  keywords = {fuzz-testing,fuzzer,fuzzing,kernel,linux,security,security-tools,security-vulnerability,testing}
}

@misc{barakVerbsProgrammingTutorial2014,
  title = {Verbs Programming Tutorial},
  author = {Barak, Dotan},
  year = {2014},
  howpublished = {https://www.cs.mtsu.edu/~waderholdt/6430/papers/ibverbs.pdf},
  file = {/home/juan/Zotero/storage/FDSBDJ58/Barak - 2014 - Verbs programming tutorial.pdf},
  language = {en}
}


@inproceedings{kaliaUsingRDMAEfficiently2014,
  title = {Using {{RDMA}} Efficiently for Key-Value Services},
  booktitle = {Proceedings of the 2014 {{ACM}} Conference on {{SIGCOMM}}},
  author = {Kalia, Anuj and Kaminsky, Michael and Andersen, David G.},
  year = {2014},
  month = aug,
  pages = {295--306},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2619239.2626299},
  abstract = {This paper describes the design and implementation of HERD, a key-value system designed to make the best use of an RDMA network. Unlike prior RDMA-based key-value systems, HERD focuses its design on reducing network round trips while using efficient RDMA primitives; the result is substantially lower latency, and throughput that saturates modern, commodity RDMA hardware. HERD has two unconventional decisions: First, it does not use RDMA reads, despite the allure of operations that bypass the remote CPU entirely. Second, it uses a mix of RDMA and messaging verbs, despite the conventional wisdom that the messaging primitives are slow. A HERD client writes its request into the server's memory; the server computes the reply. This design uses a single round trip for all requests and supports up to 26 million key-value operations per second with 5{$\mu$}s average latency. Notably, for small key-value items, our full system throughput is similar to native RDMA read throughput and is over 2X higher than recent RDMA-based key-value systems. We believe that HERD further serves as an effective template for the construction of RDMA-based datacenter services.},
  file = {/home/juan/Zotero/storage/R24EN986/Kalia et al. - 2014 - Using RDMA efficiently for key-value services.pdf},
  isbn = {978-1-4503-2836-4},
  keywords = {infiniband,key-value stores,RDMA,ROCE},
  series = {{{SIGCOMM}} '14}
}



@inproceedings{kaliaDesignGuidelinesHigh2016,
  title = {Design Guidelines for High Performance {{RDMA}} Systems},
  booktitle = {Proceedings of the 2016 {{USENIX Conference}} on {{Usenix Annual Technical Conference}}},
  author = {Kalia, Anuj and Kaminsky, Michael and Andersen, David G.},
  year = {2016},
  month = jun,
  pages = {437--450},
  publisher = {{USENIX Association}},
  address = {{USA}},
  abstract = {Modern RDMA hardware offers the potential for exceptional performance, but design choices including which RDMA operations to use and how to use them significantly affect observed performance. This paper lays out guidelines that can be used by system designers to navigate the RDMA design space. Our guidelines emphasize paying attention to low-level details such as individual PCIe transactions and NIC architecture. We empirically demonstrate how these guidelines can be used to improve the performance of RDMA-based systems: we design a networked sequencer that outperforms an existing design by 50x, and improve the CPU efficiency of a prior high-performance key-value store by 83\%. We also present and evaluate several new RDMA optimizations and pitfalls, and discuss how they affect the design of RDMA systems.},
  isbn = {978-1-931971-30-0},
  series = {{{USENIX ATC}} '16}
}


@book{jurafskySpeechLanguageProcessing2000,
  title = {Speech and {{Language Processing}}: {{An Introduction}} to {{Natural Language Processing}}, {{Computational Linguistics}}, and {{Speech Recognition}}},
  shorttitle = {Speech and {{Language Processing}}},
  author = {Jurafsky, Daniel and Martin, James H.},
  year = {2020},
  month = {Dec},
  day =  {30},
  edition = {draft},
  address = {{USA}},
  abstract = {From the Publisher: This book takes an empirical approach to language processing, based on applying statistical and other machine-learning algorithms to large corpora. Methodology boxes are included in each chapter. Each chapter is built around one or more worked examples to demonstrate the main idea of the chapter. Covers the fundamental algorithms of various fields, whether originally proposed for spoken or written language to demonstrate how the same algorithm can be used for speech recognition and word-sense disambiguation. Emphasis on web and other practical applications. Emphasis on scientific evaluation. Useful as a reference for professionals in any of the areas of speech and language processing.},
  isbn = {978-0-13-095069-7}
}


@article{hallerDowserGuidedFuzzer2013,
  title = {Dowser: A Guided Fuzzer to Find Buffer Overflow Vulnerabilities},
  author = {Haller, Istvan and Slowinska, Asia and Neugschwandtner, Matthias and Bos, Herbert},
  year = {2013},
  pages = {49--64},
  abstract = {Dowser is a 'guided' fuzzer that combines taint tracking, program analysis and symbolic execution to find buffer overflow vulnerabilities buried deep in the program's logic. Intuitively, a piece of code with convoluted pointer arithmetic instructions may be more prone to memory errors than straightforward array accesses. More importantly, the more complex the bugs and the more convoluted the pointer arithmetic, the harder it will be to find using existing techniques like random fuzzing, and static analysis.},
  file = {/home/juan/Zotero/storage/5ELJRICR/Haller et al. - Dowser a guided fuzzer to ﬁnd buffer overﬂow vuln.pdf},
  journal = {Proceedings of the 22nd USENIX Security Symposium},
  language = {en}
}

@inproceedings{ganeshTaintbasedDirectedWhitebox2009,
  title = {Taint-Based Directed Whitebox Fuzzing},
  booktitle = {2009 {{IEEE}} 31st {{International Conference}} on {{Software Engineering}}},
  author = {Ganesh, Vijay and Leek, Tim and Rinard, Martin},
  year = {2009},
  month = may,
  pages = {474--484},
  issn = {1558-1225},
  doi = {10.1109/ICSE.2009.5070546},
  abstract = {We present a new automated white box fuzzing technique and a tool, BuzzFuzz, that implements this technique. Unlike standard fuzzing techniques, which randomly change parts of the input file with little or no information about the underlying syntactic structure of the file, BuzzFuzz uses dynamic taint tracing to automatically locate regions of original seed input files that influence values used at key program attack points (points where the program may contain an error). BuzzFuzz then automatically generates new fuzzed test input files by fuzzing these identified regions of the original seed input files. Because these new test files typically preserve the underlying syntactic structure of the original seed input files, they tend to make it past the initial input parsing components to exercise code deep within the semantic core of the computation. We have used BuzzFuzz to automatically find errors in two open-source applications: Swfdec (an Adobe Flash player) and MuPDF (a PDF viewer). Our results indicate that our new directed fuzzing technique can effectively expose errors located deep within large programs. Because the directed fuzzing technique uses taint to automatically discover and exploit information about the input file format, it is especially appropriate for testing programs that have complex, highly structured input file formats.},
  file = {/home/juan/Zotero/storage/FZXLLE8V/Ganesh et al. - 2009 - Taint-based directed whitebox fuzzing.pdf;/home/juan/Zotero/storage/FH4QH674/5070546.html},
  keywords = {Artificial intelligence,Automatic testing,Character generation,Computer science,Instruments,Laboratories,Law,Legal factors,Libraries,Open source software}
}


@misc{DocumentationNetworkingQEMU,
  title = {Documentation/{{Networking}} - {{QEMU}}},
  file = {/home/juan/Zotero/storage/RHES2UHQ/Networking.html},
  howpublished = {https://wiki.qemu.org/Documentation/Networking}
}

@misc{krasnyanskyUniversalTUNTAP,
  title = {Universal {{TUN}}/{{TAP}} Device Driver},
  author = {Krasnyansky, Maxim},
  file = {/home/juan/Zotero/storage/5KCIXRK8/tuntap.html},
  howpublished = {https://www.kernel.org/doc/Documentation/networking/tuntap.txt}
}

@book{kerriskLinuxProgrammingInterface2010,
  title = {The {{Linux Programming Interface}}: {{A Linux}} and {{UNIX System Programming Handbook}}},
  shorttitle = {The {{Linux Programming Interface}}},
  author = {Kerrisk, Michael},
  year = {2010},
  edition = {First},
  publisher = {{No Starch Press}}
}

@inproceedings{shiIndustryPracticeCoverageguided2019,
  title = {Industry Practice of Coverage-Guided Enterprise {{Linux}} Kernel Fuzzing},
  booktitle = {Proceedings of the 2019 27th {{ACM Joint Meeting}} on {{European Software Engineering Conference}} and {{Symposium}} on the {{Foundations}} of {{Software Engineering}}},
  author = {Shi, Heyuan and Wang, Runzhe and Fu, Ying and Wang, Mingzhe and Shi, Xiaohai and Jiao, Xun and Song, Houbing and Jiang, Yu and Sun, Jiaguang},
  year = {2019},
  month = aug,
  pages = {986--995},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3338906.3340460},
  abstract = {Coverage-guided kernel fuzzing is a widely-used technique that has helped kernel developers and testers discover numerous vulnerabilities. However, due to the high complexity of application and hardware environment, there is little study on deploying fuzzing to the enterprise-level Linux kernel. In this paper, collaborating with the enterprise developers, we present the industry practice to deploy kernel fuzzing on four different enterprise Linux distributions that are responsible for internal business and external services of the company. We have addressed the following outstanding challenges when deploying a popular kernel fuzzer, syzkaller, to these enterprise Linux distributions: coverage support absence, kernel configuration inconsistency, bugs in shallow paths, and continuous fuzzing complexity. This leads to a vulnerability detection of 41 reproducible bugs which are previous unknown in these enterprise Linux kernel and 6 bugs with CVE IDs in U.S. National Vulnerability Database, including flaws that cause general protection fault, deadlock, and use-after-free.},
  isbn = {978-1-4503-5572-8},
  keywords = {bug detection,enterprise Linux,Kernel fuzzing},
  series = {{{ESEC}}/{{FSE}} 2019}
}

@article{liangFuzzingStateArt2018,
  title = {Fuzzing: {{State}} of the {{Art}}},
  shorttitle = {Fuzzing},
  author = {Liang, Hongliang and Pei, Xiaoxiao and Jia, Xiaodong and Shen, Wuwei and Zhang, Jian},
  year = {2018},
  month = sep,
  volume = {67},
  pages = {1199--1218},
  issn = {1558-1721},
  doi = {10.1109/TR.2018.2834476},
  abstract = {As one of the most popular software testing techniques, fuzzing can find a variety of weaknesses in a program, such as software bugs and vulnerabilities, by generating numerous test inputs. Due to its effectiveness, fuzzing is regarded as a valuable bug hunting method. In this paper, we present an overview of fuzzing that concentrates on its general process, as well as classifications, followed by detailed discussion of the key obstacles and some state-of-the-art technologies which aim to overcome or mitigate these obstacles. We further investigate and classify several widely used fuzzing tools. Our primary goal is to equip the stakeholder with a better understanding of fuzzing and the potential solutions for improving fuzzing methods in the spectrum of software testing and security. To inspire future research, we also predict some future directions with regard to fuzzing.},
  file = {/home/juan/Zotero/storage/Q9RCMGIQ/8371326.html},
  journal = {IEEE Transactions on Reliability},
  keywords = {Computer bugs,Fuzzing,reliability,security,Security,software testing,Software testing,survey},
  number = {3}
}

@inproceedings{kim2020hfl,
  title={HFL: Hybrid fuzzing on the linux kernel},
  author={Kim, Kyungtae and Jeong, Dae R and Kim, Chung Hwan and Jang, Yeongjin and Shin, Insik and Lee, Byoungyoung},
  booktitle={Proceedings of the 2020 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA},
  year={2020}
}

@inproceedings{pailoorMoonShineOptimizingOS2018,
  title = {{{MoonShine}}: {{Optimizing}} {{OS}} {{Fuzzer Seed Selection}} with {{Trace Distillation}}},
  shorttitle = {{{MoonShine}}},
  booktitle = {27th {{USENIX}} {{Security Symposium}} ({{USENIX}} {{Security}} 18)},
  author = {Pailoor, Shankara and Aday, Andrew and Jana, Suman},
  year = {2018},
  pages = {729--743},
  isbn = {978-1-939133-04-5},
  language = {en}
}


@inproceedings{hongNovelDynamicAnalysis2021,
  title = {A {{Novel Dynamic Analysis Infrastructure}} to {{Instrument Untrusted Execution Flow Across User}}-{{Kernel Spaces}}},
  booktitle = {2021 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Hong, Jiaqi and Ding, Xuhua},
  year = {2021},
  pages = {402--418},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP40001.2021.00024},
  abstract = {Code instrumentation and hardware based event trapping are two primary approaches used in dynamic malware analysis systems. In this paper, we propose a new approach called Execution Flow Instrumentation (EFI) where the analyzer execution flow is interleaved with the target flow in user- and kernel-mode, at junctures flexibly chosen by the analyzer at runtime. We also propose OASIS as the system infrastructure to realize EFI with virtues of the current two approaches, however without their drawbacks. Despite being securely and transparently isolated from the target, the analyzer introspects and controls it in the same native way as instrumentation code. We have implemented a prototype of OASIS and rigorously evaluated it with various experiments including performance and anti-analysis benchmark tests. We have also conducted two EFI case studies. The first is a cross-space control flow tracer and the second includes two EFI tools working in tandem with Google Syzkaller. One tool makes a dynamic postmortem analysis according to a kernel crash report; and the other explores the behavior of a malicious kernel space device driver which evades Syzkaller logging. The studies show that EFI analyzers are well-suited for fine-grained on-demand dynamic analysis upon a malicious thread in user or kernel mode. It is easy to develop agile EFI tools as they are user-space programs.},
  file = {/home/juan/Zotero/storage/LDQL4XVX/1mbmHSlbmvK.html},
  isbn = {978-1-72818-934-5},
  language = {English}
}
