\section{Methodology}



\subsection{Design of a Proxy Fuzzer}

Since state-of-the-art fuzzers do not directly address the challenges
posed by RDMA applications (BL), we design a fuzzer that acts like a proxy
between two machines, which communicate using RDMA.
%
% TODO: (backlink to background, remember to explain about state of Queue Pairs).

The job of the proxy is, besides from forwarding all traffic between both machines,
to identify and traffic containing specific headers that get processed by SoftRoCE.
Note that our goal is to put SoftRoCE under test, meaning that only headers that get
processed by SoftRoCE should be modified.
%
% TODO: add a section with anatomy of a base transport header

\subsection{Implementation} % maybe this is still part of design

With the help of QEMU, we create a pair of virtual machines running
our custom kernel on a x86\_64 architecture. Using debootstrap, we can easily
install a Debian system on the virtual machines, and specify all of
the required packages for our test environment.

By using TUN/TAP interfaces, we can read all network traffic that goes
through the TUN/TAP interface inside a user space program. As stated in
the Kernel documentation, these interfaces can be seen as a simple point-to-point
or ethernet device, which send and receive packets to and from a user space program.

we can connect the network interface cards
inside the virtual machines to a virtual interface visible to the host environment.
%
% briefly explain tap interfaces
%
Creating a TAP interface is possible by opening the `/dev/net/tun` device file.
With the file descriptor resulting from the previous open system call, we can ask the operating system
to create a TAP interface by issuing an ioctl system call, with the name of the interface we want to
register. Once the program ends, the operating system removes this interface, unless another ioctl call
is issued to make this interface persistent. This is what the ip tuntap command does\footnote{iproute2: https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/ }.

Unfortunately, we cannot reopen these interfaces inside our proxy fuzzer process, since the QEMU
process has already opened them; the respective ioctl system call fails and sets the
global ERRNO variable to EBUSY (device or resource busy). To overcome this, we create a pair of
virtual bridges, connect them to the tap interfaces mapped to the ethernet interfaces inside the virtual
machines, and we create additional tap interfaces and also connect them to the bridge.

%% TODO: Picture

%% TODO: explain fuzzing loop, which fields not to fuzz, removed crc checks

%% TODO: mention other approaches I tried (maybe in discussion)

%% TODO: mention the benchmarks used and the program I devised myself to exchange infiniband traffic.

%% TODO: mention implementation details, like header dumps for reproducibility, number of fuzzing rounds, fuzz after so many IB packets sent, etc.

%% TODO: mention or implement AND mention: monitoring, continuous fuzzing.

%% TODO:

%% TODO: evaluate other fuzzers
