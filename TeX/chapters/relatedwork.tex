\section{Related work}

There have been a manifold of approaches to fuzz device drivers, originating from different attack surfaces.

\subsection{DIFUZE}

Acknowledging the fact that many of the functionalities to be fulfilled by devices cannot be served through
traditional system calls like read, write and seek, DIFUZE is an interface aware fuzzing tool that targets
device drivers, by attacking the ioctl() interface\cite{difuze17}. It was designed with the linux kernel for
android devices in mind.

%% TODO: statistics of bugs in kernel with ioctl => inside  difuzerepo / presentation

One key aspect of the ioctl system call is it's intention to support generality by design.
Looking at its C prototype:

\begin{lstlisting}[language=c]
  int ioctl(int fd, int request, ... /* arg */);
\end{lstlisting}

The third (optional) argument serves as a untyped pointer to memory. This is implemented as a variadic argument, for at the time
the interface was designed, void* was not valid C. Nonetheless, the interface expects a single pointer, as opposed to potentially
many, which the variadic argument syntax would suggest.

Commonly, handlers of ioctl calls are implemented as switch statements (on the second argument) that expect specific
input on the third argument. This poses a challenge for fuzzing, as this cross dependency constitutes a problem for extracting
the definitions of the data structures expected. There are tools that leverage taint tracking to recover input formats\cite{buzzfuzz}\cite{dowser}
but for ioctls, these techniques are not very effective\cite{difuze17} because they cannot recover this cross dependency between command identifier
and optional argument.

A naive approach could be to hook into the ioctl call on a running application (possibly using the userspace infiniband verbs library
in our case), and mutate the arguments given to the ioctl call. Using techniques like the LD\_PRELOAD trick facilitates this,
but results are rarely successful, as ioctl arguments are highly constrained in nature: An undefined request code
would most likely end in a default clause that serves for catching bad request codes. Randomly modifying the optional argument
without knowledge of its underlying structure is also not very likely of success.
Nevertheless, even though not very effective, this is could still be a valid a approach to target a potentially error prone interface.

By using static analysis, DIFUZE is overcome this difficulties by analyzing the source code of the device drivers,
collecting valid request codes and their corresponding data structures to be passed as a third parameter.

DIFUZE undergoes 3 main stages to achieve its goal:

\begin{itemize}
  \item \textbf{Interface recovery:} Analyze source code and detect drivers enabled. Identify which device files are used to interact with them, which ioctl handlers they have registered and what arguments they expect to be passed. This phase outputs a set of tuples in the form of ( device filename, ioctl command, structure type definitions ). It is noteworthy that the output of this stage can also be exported in a human readable .json file, making it easily reusable for other applications.
  \item \textbf{Structure generation:} Based on the definitions recovered from the previous step, this phase prepares conforming data structures to be passed to the actual execution environment.
  \item \textbf{On-device exection:} As already mentioned, DIFUZE was specifially designed with android devices in mind. Structures that were generated are passed to the component in the target device in charge of issuing ioctl commands, while maintaining a heartbeat signal as means of monitoring for system crashes.
\end{itemize}

DIFUZE was developed with an own fuzzing engine called MangoFuzz, it is however integratable with other Fuzzers (also done by the authors), like Syzkaller.

%% originaly written with an own fuzzing engine called Mangofuzz, it can be however pipelined with other state of the art fuzzers like syzkaller as we will see, replacing steps 2 and 3.

%% NEXT STEP: RUN DIFUZE ON MY KERNEL. SHOW SOME OUTPUT RELATED TO ROCE
%% DESPITE MY EFFORTS; COULDNT GET IT TO DISCOVER SoftRoCE

\subsection{Syzkaller}

Syzkaller is a popular fuzzing tool for the linux kernel. It is however not only limited to linux, but can also be used for windows, BSD, among other
kernels.

The idea of syzkaller is fairly simple, yet its implementation is very effective: generate programs consisting of a variable number of system calls, with
concrete arguments that are increasingly mutated across iterations.

%% how does syzkaller achieve its goal

Syzkaller's architecture consists of various components: An in-host manager, called
syz-manager which is in charge of starting VMs and persisting the programs that
reside on the input corpus (back link to fuzzing) which consist of short programs issuing
system calls. It is also in charge of generating crash reports, including a minimized C reproducer program of the crash and kernel console output (like KASAN reports, or panic
messages).

Inside the VMs, the syz-fuzzer process gets started by syz-manager. If an input
corpus exists, it is given to syz-fuzzer to guide the fuzzing process. Syz-fuzzer is
in charge of modifying programs and sending them to syz-executor. In linux, programs that
are modified depend on coverage collected from sys/kernel/debug/kcov. Whenever a program seems to have triggered new coverage\footnote{code coverage generated by kcov is aimed to be stable, but this is not always the case},
it is executed repeatedly in order to make sure it does indeed trigger new coverage and is
afterwards sent back to the managing process to update the corpus.

Modifications made to programs are driven by heuristics and priorizations.\footnote{As with many other fuzzing projects, the inefficiency of searching through an enourmous space is made more bearable, by applying heuristics and priorization derived from experience: Do what usually works and not what does not likely trigger any bugs.}. Some of the highlights are\cite{bluehatil2020}:

\begin{itemize}
  \item Removing system calls might lead to new behaviour, but this is usually not the case, adding new system calls to a program usually leads to higher coverages.
  \item Mutations on the arguments of a  system call with many and complex arguments are more likely to trigger new behaviour, than rather simple ones.
  \item Add system calls that are related to others, e.g. if a program already has open, read or write are more likely to trigger an error rather than say, getpid or fork.
\end{itemize}

\subsubsection{Specifying system calls using syzlang}

As we have already discussed, the system call interface is fairly generic
(ioctl even more through its arguments). The System call description language
Syzlang is a language devised with the intention to diferentiate system calls from
another depending on their intetion.

%% One of the greatest aspects of syzkaller is its ability to declare domain specific system
%% calls through syzlang. An example of a syzlang

%% > syzlang in depth

%% difuze output for als input for syzlang



\subsection{Fastsyzkaller}

The N-Gram model, which is commonly used in the natural language processing domain,  is
used to identify vulnerable system call patterns from syzkaller generated programs in
order to make the test case generation phase more efficient.

%% many programs in corpus 1-2 statements: bad for error trigÃªrring

%% NGrams of programs gives Syzkaller a jump start



%% TODO: talk a little bit more about difuze, how it couples with syzkaller, and also try it out.
%% TODO: talk about in-memory fuzzing.
%% TODO: Talk about  syzkaller and possibly trinity.
%% TODO: Talk about Fast Syzkaller (N-Gram technique used for accelerating syzkaller execution).
%% TODO: Talk about symbolic execution (=> execute all paths using symbolic variables and solve constraints) => path explosion problem for large systems.
%%
%%
%% Mellanox has been working on defining the rdma subsystem using syzlang \cite{lpc-2018},
%% which allows syzkaller to operate exclusively on this subsystem, in order to efficiently
%% fuzz the rdma api implementation inside the linux kernel.

%% After testing syzkaller with the subset of system calls defined in the subsystem by ourselves,
%% over a hundred crashes ocurred, of which 3 of them were unique (2 kernel panics, 1 KASAN null pointer
%% dereference report).
