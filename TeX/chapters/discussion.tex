\section{Discussion}

%% talk about findings of Syzkaller and proxy fuzzer
%% talk about other tools for fuzzing network protocols and why they were not so relevant (act as clients)
TODO here goes discussion about results from previous section, and about other fuzzers that target network protocols
(why develop proxy fuzzer instead of picking one of them).

\subsection{Difficulties with other Tools}

Some tools were mentioned in Section~\ref{s:related-work} but could not be evaluated in Section~\ref{s:evaluation}.
Despite this, we consider them to be interesting approaches that build on top of state-of-the-art tools and techniques.

\subsubsection{Fastsyzkaller}

Unfortunately, Fastsyzkaller's authors did not release any source code of their contributions to open source.
It would have been difficult to reimplement Fastsyzkaller under the time frame given and also explore
other approaches.

Nevertheless, we examined the programs created by Syzkaller and compared them to programs that generate crashes.
Because Syzkaller saves the programs into a binary file called corpus.db,  extracting the programs required us
to extend Syzkaller with a module that dumps all programs in the corpus into a file. The output file contains
all programs inside the corpus separated by a marker.

From this information, we can see that many of the programs generated by Syzkaller are one, two or three system calls long.
The minimized versions of the programs that caused crashes consist of two to four system calls. This suggests
%% TODO: errors require programs that at least contain? funny and ugly.
that errors require programs that at least contain more system calls than many of those that Syzkaller generates.
In contrast with Syzkaller, Fastsyzkaller runs a modified generation algorithm, which has the tendency of creating programs
with more system calls (See Subsection~\ref{ss:fastsyzkaller}).

We consider that further exploring the N-Gram model, as a tool for recognizing vulnerable system call patterns could bring
efficiency gains. As we said, some bugs found by syzkaller are only caused by programs that consist of two system calls;
these kinds of bugs are more likely to be shallow bugs, as opposed to bugs that require a very specific program state
originating a sequence of different system calls with specific arguments.

%% LONG SYZKALLER PROGRAM TRIGGERING CRASH THAT WAS NOT REPRODUCEABLE. QP CREATION, QUERY MR AND ALL THE GOOD STUFF, VERY INTERESTING.

\subsubsection{DIFUZE}\label{ss:disc-difuze}

Inside the Syzkaller's source tree, comments containing TODOs inside the Syzlang definitions of the RDMA subsystem (``syz/linux/rdma.txt'') and
the presence of only three ioctl system call definitions led us to think that using DIFUZE for generating ioctl interface definitions
was a very promising path. The generated .json files that contain correct ioctl definitions could have been easily ported into the
Syzlang specification of the RDMA subsystem inside of Syzkaller. This could have improved Syzkaller's performance at fuzzing
the RDMA subsystem.

Despite our numerous efforts to generate interface definitions for ioctl calls by using DIFUZE,
everything we tried failed. Even though the authors provide a Docker image containing all dependencies
to run DIFUZE, the version of clang used by the authors (3.8.1) was unable to recognize
many compiler arguments of newer versions of gcc whith which the kernel was compiled. This is an essential step
for DIFUZE because it requires the exact compilation command that was run by make.
%% MAKSYM: it requires the exact compilation command that was run by make =: correct? .
After updating clang and llvm to the latest versions available at the time of this writing (13.0.0), the routine in charge of
the first stage of DIFUZE (interface recovery) ran until completion, albeit with many similar warnings
to those raised by earlier versions of clang/llvm.

Unfortunately, even though this interface recovery routine
was able to complete, there were no output files for any of the drivers that were compiled, including SoftRoCE and
RDMA core modules. The routine reports it has found zero ioctl functions to process.

\subsection{Future Work}

\subsubsection{Proxy Fuzzer}

There were some aspects of state-of-the-art Fuzzers that we could not implement, given the time constraints.
Efficient Fuzzers are complex long-time projects involving many experienced developers. Important features were left
because of this for future work, these were:

\paragraph{A Monitoring System} in charge of synchronizing the applications that communicate with each other,
as well as monitoring the target to detect crashes automatically. The Monitoring System would communicate
with a process inside the virtual machines via RPC, which would start or restart the application whenever necessary.
In the current setting, the applications must be restarted by hand whenever one side terminates the communication either by crashing
or gracefully exiting from user space. The Monitoring System would maintain a heartbeat signal with the machines, so that it knows when they have
crashed; this signal could be implemented with something simple like the Ping network utility.
They must also be restarted when the test is complete. Whenever a machine crashes, the Monitoring
System could also be in charge of two important tasks:

\begin{itemize}
\item Bring up the crashed machine by issuing the respective qemu-system command,
\item Notify the Proxy Fuzzer instance of the crash.
\end{itemize}

\paragraph{Output for Error Reproducibility:} when The Proxy Fuzzer is notified of the event of a crash, it can dump all
RDMA traffic that it forwarded since the applications started communicating, as well as the crash report
that would be provided by the Monitoring System.

\paragraph{Code Coverage Collection from Kcov:} This is an essential aspect for efficient generation of test cases.
In the context of the Proxy Fuzzer, this would shed light into which header field modifications trigger more
code paths than others. With this information, we could tune Algorithm~\ref{alg:fuzz} to adapt and focus
more on header modifications that are more likely to dismantle bugs.

\subsubsection{Syzkaller}

Syzkaller is still to the date of this writing an active project that follows the development of the Linux Kernel development
branches~\cite{shiIndustryPracticeCoverageguided2019}. Syzkaller benefits from academic
research and will continue to do so in the future, it is the center of recent research works
(~\cite{kim2020hfl},\cite{hongNovelDynamicAnalysis2021} and~\cite{pailoorMoonShineOptimizingOS2018}).
For all these reasons, it is sensible to put effort into developing a more specialized framework for continuous fuzzing
of the RDMA stack based on Syzkaller, which could be similar to the proposals of~\cite{shiIndustryPracticeCoverageguided2019}.

% UGLY
%% For all this reasons, it is a reasonable approach to develop a continuous Fuzzing Framework
%% based on Syzkaller, as proposed by~\cite{shiIndustryPracticeCoverageguided2019}.

The results of fuzzing are correlated with the quality of the seed/input files~\cite{liangFuzzingStateArt2018}.
In the case of Syzkaller, the starting point (seed) for test case generation is the set of definitions
provided through the Syzlang language. As we have seen in Subsection~\ref{ss:disc-difuze}, there is
a possibility that the RDMA subsystem Syzlang definitions could be improved.
