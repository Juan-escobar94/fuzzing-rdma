#include <stdint.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>

typedef unsigned char uchar;
#define BYTES_ICRC 4
#define BYTES_FCS 1


void print_buf_bytes(char *buf, int buf_size);

static inline void print_usage(char *p) {
    printf("Usage: %s port \n", p);
}


struct ib_bth {
  uchar opcode; // indicates iba packet type, also extension headers to follow
  int solicited_event:1; // event should be generated by responder
  int mig_reg:1; // communicates 'migration state'
  int pad_count:2; // how many extra bytes to align payload to 4-byte boundary
  int tver:4; // transport header version
  unsigned short p_key;
  uchar fr_br_reserved;
  uchar dest_qp_1;
  uchar dest_qp_2;
  uchar dest_qp_3;
  int ack_rq:1;
  int reserved:7;
  uchar psn_1;
  uchar psn_2;
  uchar psn_3;
};


struct ib_pkt {
  struct ib_bth hdr;
  char payload[];
};

struct pkt_tail {
  unsigned int icrc;
  uchar fcs;
};

void print_ib_hdr(struct ib_bth* ib_hdr) {
  puts("IB Base Transport Header:");
  printf("\topcode: %d\n", ib_hdr->opcode);
  printf("\tsolicited event: %d, mig_req: %d, pad_count: %d, tver: %d\n", ib_hdr->solicited_event, \
         ib_hdr->mig_reg, ib_hdr->pad_count, ib_hdr->tver);
  printf("\tp_key: %d\n", ib_hdr->p_key);
  printf("\tfr_br_reserved: %d\n", ib_hdr->fr_br_reserved);
  printf("\tdest_qp_1: %d\n", ib_hdr->dest_qp_1);
  printf("\tdest_qp_2: %d\n", ib_hdr->dest_qp_2);
  printf("\tdest_qp_3: %d\n", ib_hdr->dest_qp_3);
  printf("\tack_rq: %d, reserved: %d\n", ib_hdr->ack_rq, ib_hdr->reserved);
  printf("\tpsn_1: %d\n", ib_hdr->psn_1);
  printf("\tpsn_2: %d\n", ib_hdr->psn_2);
  printf("\tpsn_3: %d\n", ib_hdr->psn_3);
}


char* deserialize_ib_pkt(char* buffer, int buffer_len) {
  struct ib_bth ib_header;
  char *start_addr = buffer;
  ib_header.opcode = *buffer;
  buffer++;
  ib_header.solicited_event = (*buffer) & 0x80;
  ib_header.mig_reg = (*buffer) & 0x40;
  ib_header.pad_count = (*buffer) & 0x30;
  ib_header.tver = (*buffer) & 0x0F;
  buffer++;
  memcpy(&(ib_header.p_key), buffer, 2);
  buffer += 2;
  ib_header.fr_br_reserved = *buffer;
  buffer++;
  ib_header.dest_qp_1 = *buffer;
  buffer++;
  ib_header.dest_qp_2 = *buffer;
  buffer++;
  ib_header.dest_qp_3 = *buffer;
  buffer++;
  ib_header.ack_rq = (*buffer) & 0x80;
  ib_header.reserved = (*buffer) & 0x7F;
  buffer++;
  ib_header.psn_1 = *buffer;
  buffer++;
  ib_header.psn_2 = *buffer;
  buffer++;
  ib_header.psn_3 = *buffer;
  buffer++;
  print_ib_hdr(&ib_header);
  int padding_bytes = ib_header.pad_count;
  char* padding = malloc(padding_bytes);
  for (int i = 0; i < padding_bytes; i++) buffer++;
  /*
   *  Now buffer should point to payload
   */
  int ib_payload_len = buffer_len - (sizeof(ib_header) + padding_bytes + \
      BYTES_ICRC + BYTES_FCS);
  printf("\tbuffer_len: %d, payload_len: %d\n", buffer_len, ib_payload_len);
  fflush(stdout);
  char* payload = malloc(ib_payload_len);
  memcpy(payload, buffer, ib_payload_len);

  return start_addr;
}


struct ports_record {
  char client_port[NI_MAXSERV];
  char server_port[NI_MAXSERV];
};



/**
 * basic idea: open two sockets 
 * -one for listening bound to addr1
 * -two for forwarding to addr2
 *
 *
 * */

int main (int argc, char** argv) {

    if (argc != 2) {
       print_usage(argv[1]);
       exit(1); 
    }
    struct ports_record pr;
    int status;
    int sd_listen, sd_fw_toclient, sd_fw_toserv;
    struct addrinfo hints, *res;

    struct addrinfo *res_client, *res_client_xch, *res_server, *res_server_xch;

    memset(&hints, 0, sizeof(hints));
    // AF_UNSPEC: use either IPv4 or IPv6
    // AF_INET: use IPv4
    // AF_INET6: use IPv6 
    hints.ai_family = AF_INET; 
    // use UDP
    hints.ai_socktype = SOCK_DGRAM;
    // fill in my own IP for me
    hints.ai_flags = AI_PASSIVE;

    status = getaddrinfo(NULL, argv[1], &hints, &res);
    if (status != 0) {
      perror("getaddrinfo");
      exit(1);
    }

    sd_listen = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sd_listen == -1) {
      perror("socket");
      exit(1);
    }
  
    status = bind(sd_listen, res->ai_addr, res->ai_addrlen);
    if (status != 0) {
      perror("bind");
      exit(1);
    }

    printf("ready to receive on port %s\n", argv[1]);
    /*
     *
     * now prepare the data structures to forward the message
     *
     **/
    freeaddrinfo(res);


    status = getaddrinfo(NULL, "9001", &hints, &res_client);
    if (status != 0) {
      perror("getaddrinfo");
      exit(1);
    }

    sd_fw_toclient = socket(res_client->ai_family, res_client->ai_socktype, res_client->ai_protocol);
    if (sd_listen == -1) {
      perror("socket");
      exit(1);
    }

    status = getaddrinfo(NULL, "9003", &hints, &res_client_xch);
    if (status != 0) {
      perror("getaddrinfo");
      exit(1);
    }

    int sd_fw_toclient_xch = socket(res_client_xch->ai_family, res_client_xch->ai_socktype, res_client_xch->ai_protocol);
    if (sd_listen == -1) {
      perror("socket");
      exit(1);
    }

    status = getaddrinfo(NULL, "8001", &hints, &res_server);
    if (status != 0) {
      perror("getaddrinfo");
      exit(1);
    }

    sd_fw_toserv = socket(res_server->ai_family, res_server->ai_socktype, res_server->ai_protocol);
    if (sd_listen == -1) {
      perror("socket");
      exit(1);
    }

    status = getaddrinfo(NULL, "8003", &hints, &res_server_xch);
    if (status != 0) {
      perror("getaddrinfo");
      exit(1);
    }

    int sd_fw_toserv_xch = socket(res_server_xch->ai_family, res_server_xch->ai_socktype, res_server_xch->ai_protocol);
    if (sd_listen == -1) {
      perror("socket");
      exit(1);
    }
    fflush(stdout);
    char buf[4096];
    char* msg;
    memset(&buf, 0, sizeof(buf));
    int received;
    _Bool client_flag = 0;
    _Bool server_flag = 0;

    char sender_hostname[NI_MAXHOST];
    char sender_port[NI_MAXSERV];
    struct sockaddr_storage sender;
    socklen_t sender_len = sizeof(struct sockaddr_storage);
    while ((received = recvfrom(sd_listen, &buf, sizeof buf, 0, \
                                (struct sockaddr*) &sender,  &sender_len)) != -1) {

      // char* p = &buf[0];

      print_buf_bytes(buf, received);

      fflush(stdout);

      /*
         *
         * client is assumed to send the first packet, which should be then stored in a record
         * struct, afterwards should be the server, stored in the same record. only fuzz packets
         * incoming from the client after the connection has been succesfully set.
         *
         * */
      getnameinfo((struct sockaddr*)&sender, sender_len, sender_hostname, sizeof sender_hostname, \
                  sender_port, sizeof sender_port, NI_NUMERICHOST | NI_NUMERICSERV);

      printf("from port %s\n", sender_port);
      if (!client_flag) {
        memcpy(pr.client_port, sender_port, sizeof pr.client_port);
        client_flag = 1;
        printf("forwarding xch to server\n");
        sendto(sd_fw_toserv_xch, &buf, sizeof buf, 0, (struct sockaddr*) res_server_xch->ai_addr, sizeof *(res_server_xch->ai_addr));
        freeaddrinfo(res_server_xch);
      } else if (!server_flag) {
        memcpy(pr.server_port, sender_port, sizeof pr.server_port);
        server_flag = 1;
        printf("forwarding xch to client\n");
        sendto(sd_fw_toclient_xch, &buf, sizeof buf, 0, (struct sockaddr*) res_client_xch->ai_addr, sizeof *(res_client_xch->ai_addr));
        freeaddrinfo(res_client_xch);
      }
        // incoming packet from client, forward to server
      else if(strcmp(pr.client_port, sender_port) == 0) {
          printf("forwarding to server\n");
          sendto(sd_fw_toserv, &buf, sizeof buf, 0, (struct sockaddr*) res_server->ai_addr, sizeof *(res_server->ai_addr));
        } else if (strcmp(pr.server_port, sender_port) == 0) {
          printf("forwarding to client\n");
          sendto(sd_fw_toclient, &buf, sizeof buf, 0, (struct sockaddr*) res_client->ai_addr, sizeof *(res_client->ai_addr));
        } else {
          printf("unknown sender\n");
        }








      /**
       *
       * parse and fuzz the IB packet before forwarding it again
       *
       **/
      char* buffer_cp = &buf[0];
      // deserialize_ib_pkt(buffer_cp, received);
      memset(&buf, 0, sizeof(buf));
    } 


    return 0;
}

void print_buf_bytes(char *buf, int buf_size) {

  // dont modify the actual buf.
  char *p = buf;
  int bytes_range = 0x0000;
  printf("received: \n");
  int k = 0;
  while ( k <= buf_size){
    printf("%04X: ", bytes_range & 0xFFFF);
    for (int i = 1; i <= 16; i++){
      if (k >= buf_size) return;

      printf("%02X", (*p) & 0xFF);
      if (i % 2 == 0 ) printf(" ");
      k++;
      p++;
    }
    printf("\n");
    bytes_range += 16;
  }
  printf("\n");
}
